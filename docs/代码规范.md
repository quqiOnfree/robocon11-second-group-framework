# C++代码规范 v1.0 - Modern C++风格

## 一、命名规范（下划线风格）

### 1.1 基础规则
```cpp
// ✅ 正确
int connection_count;
void process_packet();
float calculate_average(const std::vector<float>& data);

// ❌ 避免
int connectionCount;      // 驼峰（Java风格）
void ProcessPacket();     // 帕斯卡（C#风格）
```

### 1.2 类与结构体
```cpp
// 类型：蛇形命名（snake_case）
class network_manager {
public:
    // 构造函数/析构函数：与类名相同
    network_manager();
    ~network_manager();
    
    // 公开成员函数：下划线
    void start_service();
    
private:
    // 私有成员变量：m_前缀 + 下划线
    int m_socket_fd;
    std::string m_server_address;
    
    // 私有成员函数：下划线
    void setup_socket();
};

// 结构体：也使用蛇形命名
struct packet_header {
    uint32_t magic_number;  // 结构体成员通常不需要m_前缀
    uint16_t packet_size;
};
```

### 1.3 模板与类型别名
```cpp
// 模板参数：使用大写的单字母或简短单词
template<typename T, typename Allocator>
class custom_container;

// 类型别名：蛇形命名 + _t（可选）
using packet_handler = std::function<void(const packet&)>;
using byte_array = std::vector<uint8_t>;
using device_id_t = uint32_t;
```

### 1.4 常量与枚举
```cpp
// ✅ 推荐constexpr常量：全小写（C++17开始可用）
constexpr int default_port = 8080;
constexpr float pi = 3.141592653589793f;

// ❌ 避免宏常量：全大写 + 下划线
#define MAX_BUFFER_SIZE 4096
#define ENABLE_LOGGING 1

// 枚举类：蛇形命名
enum class connection_state {
    disconnected,
    connecting,
    connected,
    error
};

// 枚举值：全小写 + 下划线
enum class error_code {
    success = 0,
    timeout_error,
    invalid_parameter,
    resource_busy
};

// 全小写是因为宏命名一般是"全大写 + 下划线"，
// 如果其他也这么写容易被替换，导致错误
```

## 二、类型安全与转换

### 2.1 禁止C风格转换
```cpp
// ❌ 绝对禁止
float x = 10.5f;
int y = (int)x;          // C风格转换
int z = int(x);          // 函数风格转换（同样危险）

// ✅ 使用C++风格转换
int a = static_cast<int>(x);      // 明确的数值转换
auto ptr = static_cast<Base*>(derived_ptr);  // 向上转型

// ✅ 特殊情况
auto raw_ptr = reinterpret_cast<uint8_t*>(register_address); // 硬件寄存器
auto const_ptr = const_cast<char*>(str.data());              // 移除const
auto derived = dynamic_cast<Derived*>(base_ptr);             // 运行时检查
```

### 2.2 智能指针使用规范
```cpp
// ✅ 推荐做法
std::unique_ptr<Device> device = std::make_unique<Device>();
std::shared_ptr<Resource> resource = std::make_shared<Resource>();

// 传递所有权时使用std::move
std::unique_ptr<Data> data = acquire_data();
process_data(std::move(data));  // data现在为nullptr

// ❌ 避免
std::shared_ptr<Object> obj(new Object());  // 避免直接new
std::auto_ptr<Old> old_ptr;                // 已废弃
```

## 三、函数参数与迭代器

### 3.1 参数传递原则
```cpp
// ✅ 通用规则
// 1. 输入参数：const引用或值传递（小对象）
void process_data(const std::vector<int>& data);  // 大对象，只读
void update_value(int value);                     // 小对象，值传递

// 2. 输出参数：引用
bool find_user(const std::string& name, User& result);

// 3. 输入输出参数：非const引用
void transform_data(std::vector<float>& data);

// 4. 可选输出：指针（可以为nullptr）
bool try_parse(const char* str, int* result = nullptr);
```

### 3.2 迭代器参数（核心优势）
```cpp
// ✅ 通用算法使用迭代器
template<typename InputIt, typename OutputIt>
OutputIt transform_data(InputIt first, InputIt last, OutputIt d_first) {
    while (first != last) {
        *d_first++ = process(*first++);
    }
    return d_first;
}

// ✅ 使用时传递容器或原始数组
std::vector<int> source = {1, 2, 3, 4};
std::vector<int> destination;

// 使用容器迭代器
transform_data(source.begin(), source.end(), 
               std::back_inserter(destination));

// 使用原始数组（同样安全）
int raw_array[] = {1, 2, 3, 4};
int output[4];
transform_data(std::begin(raw_array), std::end(raw_array), output);
```

### 3.3 现代C++参数技术
```cpp
// 使用string_view代替const std::string&
void process_string(std::string_view str);

// 使用span代替指针+大小（C++20）
void process_bytes(std::span<const uint8_t> data);

// 完美转发模板
template<typename... Args>
void emplace_object(Args&&... args) {
    m_object.emplace_back(std::forward<Args>(args)...);
}
```

## 四、类设计规范

### 4.1 构造函数与RAII
```cpp
class resource_handler {
public:
    // 构造函数：初始化所有成员
    explicit resource_handler(const std::string& path)
        : m_path(path)
        , m_handle(open_resource(path.c_str()))
        , m_is_valid(m_handle != nullptr) {
        
        if (!m_is_valid) {
            throw std::runtime_error("Failed to open resource");
        }
    }
    
    // 禁用拷贝，允许移动
    resource_handler(const resource_handler&) = delete;
    resource_handler& operator=(const resource_handler&) = delete;
    
    resource_handler(resource_handler&& other) noexcept
        : m_path(std::move(other.m_path))
        , m_handle(other.m_handle)
        , m_is_valid(other.m_is_valid) {
        other.m_handle = nullptr;
        other.m_is_valid = false;
    }
    
    ~resource_handler() {
        if (m_is_valid) {
            close_resource(m_handle);
        }
    }
    
private:
    std::string m_path;
    resource_handle* m_handle;
    bool m_is_valid;
};
```

### 4.2 接口设计
```cpp
// 使用final禁止继承（除非设计为基类）
class final_class final {
public:
    virtual ~final_class() = default;
    
    // 接口函数标记为virtual
    virtual void process() = 0;
    
    // 非虚函数不要override
    void utility_function() const;
};

// 实现类
class implementation : public final_class {
public:
    void process() override;  // 明确使用override关键字
};
```

## 五、内存与资源管理

### 5.1 嵌入式特化规则
```cpp
#ifdef EMBEDDED_SYSTEM
    // 嵌入式环境：禁用动态内存
    #define NO_DYNAMIC_ALLOCATION
    
    // 使用静态分配容器
    using buffer = std::array<uint8_t, 1024>;
    
    // 禁用异常
    #define NO_EXCEPTIONS
#else
    // 桌面/服务器环境：正常使用
    using buffer = std::vector<uint8_t>;
#endif

class embedded_safe_container {
public:
    // 编译时大小检查
    template<size_t N>
    void copy_data(const uint8_t (&data)[N]) {
        static_assert(N <= BUFFER_SIZE, "Data too large");
        std::copy(std::begin(data), std::end(data), m_buffer.begin());
    }
    
private:
    static constexpr size_t BUFFER_SIZE = 512;
    std::array<uint8_t, BUFFER_SIZE> m_buffer;
};
```

## 六、异常与错误处理

### 6.1 异常使用策略
```cpp
// 桌面/服务器：使用异常
class data_processor {
public:
    data load_data(const std::string& filename) {
        std::ifstream file(filename);
        if (!file) {
            throw std::runtime_error("Cannot open file: " + filename);
        }
        return parse_file(file);
    }
};

// 嵌入式/高性能：使用错误码
class embedded_device {
public:
    enum class error {
        success,
        timeout,
        bus_error,
        invalid_parameter
    };
    
    [[nodiscard]] error initialize() noexcept {
        if (!check_hardware()) {
            return error::bus_error;
        }
        return error::success;
    }
};
```

## 七、函数返回值优化（RVO/NRVO）

### 7.1 核心原则：禁止显式std::move返回值
```cpp
// ❌ 绝对禁止：显式move会干扰编译器优化
class large_object {
public:
    std::vector<int> data;
    // 其他成员...
};

large_object bad_return() {
    large_object obj;
    obj.data.resize(1000000);
    return std::move(obj);  // ❌ 禁止！破坏RVO/NRVO
}

// ✅ 正确：让编译器自动优化
large_object good_return() {
    large_object obj;
    obj.data.resize(1000000);
    return obj;  // ✅ 编译器会应用RVO或NRVO
}
```

### 7.2 RVO与NRVO的区别与优化
```cpp
// RVO (Return Value Optimization) - 返回临时对象
// 编译器会直接在调用者的栈帧上构造返回值
large_object rvo_example() {
    return large_object();  // 临时对象，编译器优化为零拷贝
}

// NRVO (Named Return Value Optimization) - 返回命名对象
// 编译器会直接在调用者的栈帧上构造命名对象
large_object nrvo_example() {
    large_object obj;
    obj.data.resize(1000000);
    return obj;  // 命名对象，同样可被优化为零拷贝
}

// 两种情况在C++17及以后都保证优化，不需要std::move
```

### 7.3 最佳实践
```cpp
// 1. 简单情况：直接返回
std::string get_name() {
    return "Alice";  // RVO：字符串会直接在返回位置构造
}

// 2. 复杂对象：构建后返回
std::vector<int> generate_data(size_t count) {
    std::vector<int> result;
    result.reserve(count);
    for (size_t i = 0; i < count; ++i) {
        result.push_back(i);
    }
    return result;  // NRVO：result在返回位置构造，零拷贝
}

// 3. 条件返回：仍然依赖NRVO
std::string conditional_return(bool use_default) {
    std::string result;
    if (use_default) {
        result = "default";
    } else {
        result = "custom";
    }
    return result;  // ✅ 现代编译器会优化，不需要std::move
}

// 4. 禁止这样做
std::string bad_conditional(bool use_default) {
    std::string result;
    if (use_default) {
        return "default";  // ❌ 混合return路径可能失效NRVO
    }
    return result;         // 但这种情况下使用std::move也不推荐
}

// 5. 正确的多返回路径
std::string correct_conditional(bool use_default) {
    if (use_default) {
        return "default";  // ✅ 单个return点，RVO生效
    } else {
        return "custom";   // ✅ 单个return点，RVO生效
    }
}
```

### 7.4 何时可以使用std::move
```cpp
// 仅在以下特定情况使用std::move：

// 1. 显式所有权转移（非返回值）
std::unique_ptr<Resource> resource = std::make_unique<Resource>();
store_resource(std::move(resource));  // ✅ 转移所有权，resource变为nullptr

// 2. 参数转发（完美转发）
template<typename T>
void wrapper(T&& value) {
    process(std::forward<T>(value));  // ✅ 转发参数的值类别
}

// 3. 与容器操作配合
std::vector<std::string> strings;
std::string local = "hello";
strings.push_back(std::move(local));  // ✅ 显式移动到容器

// 但绝不在函数return语句中使用
```

### 7.5 编译器支持保证
```cpp
// C++17及以后的保证：

// 情况1：临时对象必定被优化（强制RVO）
class complex_object { /* 非平凡构造/析构 */ };
complex_object factory() {
    return complex_object();  // C++17: 强制优化，不需要move语义
}

// 情况2：命名对象可被优化（NRVO，非强制但几乎总是优化）
complex_object create() {
    complex_object obj;
    // ... 初始化 ...
    return obj;  // C++17: 编译器几乎总会优化这个
}

// 即使编译器跳过优化，也会自动使用move语义
// 所以显式std::move反而会阻止编译器选择最优策略
```

### 7.6 编译选项建议
```bash
# 确保启用优化
g++ -O2 -std=c++17 -Wall -Wextra code.cpp

# 检查RVO是否生效（使用-fno-elide-constructors禁用来验证代码正确性）
g++ -fno-elide-constructors -O2 code.cpp  # 会失败则代码有问题

# Clang同样支持RVO/NRVO
clang++ -O2 -std=c++17 code.cpp
```

## 八、模板与泛型编程

### 8.1 模板规范
```cpp
// 模板参数要求文档化
template<typename T>
concept numeric = std::is_arithmetic_v<T>;

template<numeric T>
class statistics {
public:
    T calculate_average(const T* data, size_t size) const;
};

// 类型别名提升可读性
template<typename Key, typename Value>
using dictionary = std::unordered_map<Key, Value>;

// 使用auto推导返回类型
template<typename Container>
auto get_first_element(const Container& c) -> decltype(*c.begin()) {
    if (c.empty()) {
        throw std::out_of_range("Container is empty");
    }
    return *c.begin();
}
```

## 九、代码格式化（自动工具）

### 8.1 `.clang-format`配置建议
```yaml
BasedOnStyle: LLVM
IndentWidth: 4
TabWidth: 4
UseTab: Never
BreakBeforeBraces: Allman
AllowShortFunctionsOnASingleLine: None
AllowShortIfStatementsOnASingleLine: false
ColumnLimit: 100
PointerAlignment: Left
NamespaceIndentation: All
FixNamespaceComments: true
```

### 8.2 提交前检查脚本
```bash
#!/bin/bash
# pre-commit-hook.sh

# 1. 格式化检查
clang-format -i --style=file *.cpp *.hpp

# 2. 静态分析
clang-tidy --fix *.cpp -- -I./include

# 3. 编译检查
mkdir -p build && cd build
cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..
make -j$(nproc)

# 4. 运行单元测试
ctest --output-on-failure
```

## 十、代码审查清单

### 10.1 必须检查项
- [ ] 所有类成员变量使用`m_`前缀
- [ ] 无C风格转换（使用`static_cast`等）
- [ ] 迭代器/范围参数代替指针+大小
- [ ] 资源管理类遵循RAII
- [ ] 移动操作标记为`noexcept`（如果适用）
- [ ] 禁用不需要的拷贝操作
- [ ] `const`正确性：成员函数是否应为`const`
- [ ] 引用参数是否应为`const`

### 10.2 建议检查项
- [ ] 函数长度不超过50行
- [ ] 圈复杂度小于10
- [ ] 使用`[[nodiscard]]`标记必须检查返回值的函数
- [ ] 使用`constexpr`标记编译时常量
- [ ] 避免裸`new`/`delete`
- [ ] 使用`enum class`代替普通`enum`

## 十一、团队协作规范

### 11.1 分支策略
```
main (受保护)
├── develop (集成分支)
│   ├── feature/xxx (功能分支)
│   ├── bugfix/xxx (修复分支)
│   └── refactor/xxx (重构分支)
└── release/v1.x.x (发布分支)
```

### 11.2 提交消息格式
```
类型(范围): 简短描述

详细描述（可选）

- 项目符号列表
- 说明更改原因
- 列出破坏性变更

关联Issue: #123
```

类型：feat, fix, docs, style, refactor, test, chore

## 十二、示例完整代码

```cpp
// network_manager.hpp
#pragma once

#include <vector>
#include <memory>
#include <string_view>

class network_manager {
public:
    explicit network_manager(uint16_t port);
    ~network_manager();
    
    network_manager(const network_manager&) = delete;
    network_manager& operator=(const network_manager&) = delete;
    
    network_manager(network_manager&& other) noexcept;
    network_manager& operator=(network_manager&& other) noexcept;
    
    [[nodiscard]] bool start_service();
    void stop_service();
    
    template<typename InputIt>
    size_t send_data(InputIt first, InputIt last);
    
    void set_timeout(uint32_t milliseconds) noexcept;
    
private:
    void setup_socket();
    void close_socket() noexcept;
    
    int m_socket_fd;
    uint16_t m_port;
    bool m_is_running;
    uint32_t m_timeout_ms;
};

// 实现
template<typename InputIt>
size_t network_manager::send_data(InputIt first, InputIt last) {
    size_t total_sent = 0;
    while (first != last) {
        ssize_t sent = send(m_socket_fd, &*first, 1, 0);
        if (sent < 0) {
            throw std::runtime_error("Send failed");
        }
        ++first;
        ++total_sent;
    }
    return total_sent;
}
```

## 十三、工具链配置

### 13.1 CMake基础配置
```cmake
cmake_minimum_required(VERSION 3.15)
project(MyProject LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# 警告设置
if(MSVC)
    add_compile_options(/W4 /WX)
else()
    add_compile_options(-Wall -Wextra -Wpedantic -Werror)
endif()

# 添加项目
add_library(core STATIC src/core.cpp)
target_include_directories(core PUBLIC include)

add_executable(main src/main.cpp)
target_link_libraries(main PRIVATE core)
```

### 13.2 建议的编译器标志
```bash
# 调试版本
-g -O0 -DDEBUG -fsanitize=address,undefined

# 发布版本
-O2 -DNDEBUG -flto

# 嵌入式版本
-Os -ffunction-sections -fdata-sections -Wl,--gc-sections
```
